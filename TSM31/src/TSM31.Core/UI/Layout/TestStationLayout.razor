@inherits LayoutComponentBase
@inject DielectricTestManager TestManager
@inject StartupService StartupOrchestrator
@inject SessionManager SessionHandler
@implements IDisposable

<FluentDesignTheme Mode="DesignThemeModes.Dark" OfficeColor="OfficeColor.Default"/>
<FluentDialogProvider/>
<FluentTooltipProvider/>

<div class="test-station-layout-wrapper">
  <div class="test-station-layout flex flex-col w-full h-screen p-2 border border-neutral-500">


    <div class="main-content flex flex-row flex-1 overflow-y-hidden">
      <div
        class="menu-left-wrapper flex flex-col flex-shrink-0 bg-neutral-layer-1 border-r border-neutral-stroke-divider-rest">
        <div class="keyboard-nav-menu flex-1 overflow-y-auto">
          <MenuComponent/>
        </div>
        <!-- Test Power Control -->
        <div class=" test-power flex flex-col p-4 gap-2 border-t border-neutral-stroke-divider-rest" inert>
          <FluentLabel Typo="Typography.H5" Class="font-semibold text-center">
            Test Power
          </FluentLabel>
          <FluentButton Class="min-h-14 text-2xl font-bold" BackgroundColor="rgba(255,0,0,255)"
                        OnClick="@ToggleTestPower">
            OFF
          </FluentButton>
          <FluentLabel Typo="Typography.H5" Class="text-center italic text-xs">
            Write Disabled
          </FluentLabel>
        </div>
      </div>

      <div class="body-wrapper px-2 mb-2 flex flex-col flex-1 gap-2 min-h-0">
        <div class="transformer-bar-wrapper flex-shrink-0 bg-neutral-layer-2 p-2">
          <TransformerDataBar/>
        </div>


        <div class="dynamic-content-wrapper flex-1 overflow-auto bg-neutral-layer-2 p-2 rounded border border-neutral-stroke-rest justify-center min-h-0">
          @Body
        </div>
        <div class="messages-bar-wrapper flex-shrink-0">
          <MessagesBar/>
        </div>

      </div>
    </div>


    <!-- Footer - Status Bar -->
    <div
      class="status-bar flex flex-wrap gap-x-6 gap-y-1 px-4 py-1 bg-neutral-layer-2 border-t border-neutral-stroke-divider-rest">
      <FluentLabel Typo="Typography.H5" Class="whitespace-nowrap">Params Up-To-Date</FluentLabel>
      <FluentLabel Typo="Typography.H5" Class="whitespace-nowrap">
        Operator: @(TestManager.CurrentOperator?.Name ?? "Not Logged In")
      </FluentLabel>
      <FluentLabel Typo="Typography.H5" Class="whitespace-nowrap ml-auto">
        METER STATUS: 120:00:00
      </FluentLabel>
      <FluentLabel Typo="Typography.H5" Class="whitespace-nowrap">
        @DateTime.Now.ToString("MMMM dd, yyyy")
      </FluentLabel>
      <FluentLabel Typo="Typography.H5" Class="whitespace-nowrap">
        @DateTime.Now.ToString("HH:mm")
      </FluentLabel>
      <FluentLabel Typo="Typography.H5" Class="whitespace-nowrap">Version 00.00.00</FluentLabel>
    </div>

  </div>
</div>

<!-- Dialogs -->
<SplashScreenDialog @ref="_splashDialog"/>
<OperatorIdDialog @ref="_operatorLoginDialog"/>
<OperatorRestoreDialog @ref="_operatorRestoreDialog" OnChoice="HandleOperatorRestoreChoice"/>


@code {
  private SplashScreenDialog? _splashDialog;
  private OperatorIdDialog? _operatorLoginDialog;
  private OperatorRestoreDialog? _operatorRestoreDialog;

  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    if (!firstRender) return;

    Console.WriteLine("[TestStationLayout] Initializing layout...");

    // Subscribe to events before initialization to ensure UI updates correctly
    SubscribeToEvents();

    // Execute complete startup sequence via orchestration service
    var startupResult = await StartupOrchestrator.ExecuteStartupSequenceAsync();

    // Display appropriate dialog based on startup result
    ShowInitialDialog(startupResult);

    // Setup splash screen callback for post-splash operator handling
    ConfigureSplashDialogCallback();
  }

  /// <summary>
  /// Subscribes to all necessary events for state management.
  /// </summary>
  private void SubscribeToEvents()
  {
    TestManager.OnOperatorChanged += OnOperatorChanged;
    TestManager.OnUnitDataChanged += HandleUnitDataChanged;
    TestManager.OnShowOperatorDialog += () => _operatorLoginDialog?.Show();
  }

  /// <summary>
  /// Displays the appropriate initial dialog based on startup orchestration results.
  /// </summary>
  private void ShowInitialDialog(StartupResult result)
  {
    Console.WriteLine("[TestStationLayout] Displaying initial dialog based on startup result...");
    switch (result.Dialog)
    {
      case DialogToShow.Splash:
        _splashDialog?.Show();
        break;

      case DialogToShow.OperatorRestore:
        _operatorRestoreDialog?.Show(result.SavedSession!);
        break;

      case DialogToShow.OperatorLogin:
        _operatorLoginDialog?.Show();
        break;

      case DialogToShow.None:
        // No dialog needed - operator already logged in
        break;
    }
  }

  /// <summary>
  /// Configures the splash screen callback to handle operator session after splash closes.
  /// </summary>
  private void ConfigureSplashDialogCallback()
  {
    if (_splashDialog == null) return;

    _splashDialog.OnSplashClosed += async () => {
      if (TestManager.IsOperatorLoggedIn) return;

      // Check for saved session after splash closes
      var savedSession = await SessionHandler.GetSavedSessionAsync();
      // if null
      if (savedSession == null)
      {
        Console.WriteLine("[TestStationLayout] Saved session not found after splash.");
      }
      else
      {
        Console.WriteLine($"[TestStationLayout] Saved session found after splash for operator: {savedSession.Operator?.Name}");
      }

      if (savedSession?.Operator != null)
      {
        _operatorRestoreDialog?.Show(savedSession);
      }
      else
      {
        Console.WriteLine("[TestStationLayout] Showing operator login dialog after splash.");
        _operatorLoginDialog?.Show();
      }
    };
  }

  /// <summary>
  /// Handles the user's choice from the operator restore dialog.
  /// </summary>
  /// <param name="restore">True = restore session, False = start fresh</param>
  private async Task HandleOperatorRestoreChoice(bool restore)
  {
    if (restore)
    {
      await RestoreOperatorSessionAsync();
    }
    else
    {
      await StartFreshOperatorSessionAsync();
    }
  }

  /// <summary>
  /// Restores a previous operator session from saved state.
  /// </summary>
  private async Task RestoreOperatorSessionAsync()
  {
    var savedSession = await SessionHandler.GetSavedSessionAsync();

    if (savedSession?.Operator == null)
    {
      _operatorLoginDialog?.Show();
      return;
    }

    var success = await SessionHandler.RestoreSessionAsync(savedSession);

    if (!success)
    {
      _operatorLoginDialog?.Show();
    }

    StateHasChanged();
  }

  /// <summary>
  /// Starts a fresh operator session (clears saved operator, prompts for login).
  /// </summary>
  private async Task StartFreshOperatorSessionAsync()
  {
    await SessionHandler.StartFreshSessionAsync();
    _operatorLoginDialog?.Show();
  }

  private void OnOperatorChanged() => StateHasChanged();

  private void ToggleTestPower() => StateHasChanged();

  private void HandleUnitDataChanged() => InvokeAsync(StateHasChanged);

  public void Dispose()
  {
    TestManager.OnUnitDataChanged -= HandleUnitDataChanged;
    TestManager.OnOperatorChanged -= OnOperatorChanged;
  }
}
